searchState.loadedDescShard("hotshot_state_prover", 0, "SNARK-assisted <code>HotShot</code> light client state update …\nState verifier circuit builder Circuit implementation for …\nLegacy prover Legacy prover\nUtilities for test\nProver service related functionalities A light client …\nSNARK proof generation\nPublic input to the light client state prover service\nLight client state Variable\nVariable for stake table entry\nLight client state Variable The stake table commitment is …\nA function that takes as input:\nInternal function to build a dummy circuit\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a public input from light client state and …\nErrors\nErrors\nCommitment for QC verification keys\nStake amount\nCommitment for stake amount\nCommitment for state verification keys\nstate verification keys\nThreshold for quorum signatures\nConvert to a vector of field elements\nState verifier circuit builder Legacy circuit …\nUtilities for test\nProver service related functionalities A light client …\nSNARK proof generation\nPublic input to the light client state prover service\nLight client state Variable\nVariable for stake table entry\nLight client state Variable The stake table commitment is …\nA function that takes as input:\nInternal function to build a dummy circuit\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a public input from light client state and …\nErrors\nErrors\nCommitment for QC verification keys\nStake amount\nCommitment for stake amount\nCommitment for state verification keys\nstate verification keys\nThreshold for quorum signatures\nConvert to a vector of field elements\nMock of hotshot ledger for testing LightClient.sol …\nMock for system parameter of <code>MockLedger</code>\nStake table capacity used for testing\nElapse a view with a new finalized block\nElapse a view without a new finalized block (e.g. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nreturn list of (proof, ver_key, public_input, extra_msg, …\nReturn the light client state and proof of consensus on …\na malicious attack, generating a fake stake table full of …\nInit the system parameters (some fixed, some adjustable)\nInitialize the ledger with genesis state\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper function for test\nReturns the light client state\nmax capacity of stake table\nHelper function for test\nReturns the stake table state for current voting\nGet the latest LightClientState and signature bundle from …\nCheck if the contract is a legacy contract. Returns true …\nRead the following info from the LightClient contract …\nRun light client state prover once\nRun prover in daemon mode\nsubmit the latest finalized state along with a proof to …\nSync the light client state from the relay server and …\nProof\nProving key\nPublic input to the light client state prover service\nUniversal SRS\nVerifying key\n\\beta times the above generator of G2.\nThe size of the evaluation domain. Should be a power of …\nGiven a proving key and\nTODO: remove h and beta_h The generator of G2.\nA flag indicating whether the key is a merged key.\nThe constants K0, …, K_num_wire_types that ensure wire …\nThe number of public inputs.\nKZG PCS opening key.\n(Aggregated) proof of evaluations at challenge point <code>zeta</code>.\nThe partial proof for Plookup argument\nPlookup verifying key, None if not support lookup.\nPolynomial evaluations.\nGroup elements of the form <code>{ \\beta^i G }</code>, where <code>i</code> ranges …\npowers of \\beta time the generator h of G2\nGiven a SRS, returns the proving key and verifying key for …\nThe polynomial commitment for the wire permutation …\nThe selector polynomial commitments. The commitments are …\n(Aggregated) proof of evaluation at challenge point …\nThe permutation polynomial commitments. The commitments …\nSplit quotient polynomial commitments.\nThe verifying key. It is used by prover to initialize …\nWire witness polynomials commitments.\nNumber of block per epoch for testing\nOur “first epoch” in test is epoch 2: …\nMock of hotshot ledger for testing LightClient.sol …\nMock for system parameter of <code>MockLedger</code>\nStake table capacity used for testing\nreturns the current epoch\ncompute the epoch corresponding to <code>height</code>\nElapse a view with a new finalized block\nElapse a view without a new finalized block (e.g. …\nreturn true if epoch is activated\nnumber of block per epoch\nindicate the first epoch\nreturn the first epoch (activation epoch)\nReturns the argument unchanged.\nReturns the argument unchanged.\nreturn list of (proof, ver_key, public_input, extra_msg, …\nReturn the light client state and proof of consensus on …\na malicious attack, generating a fake stake table full of …\nInit the system parameters (some fixed, some adjustable)\nInitialize the ledger with genesis state\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nreturn true of the current state is epoch root since it …\nreturn true of the current state is between epoch root and …\nHelper function for test\nReturns the light client state\nReturns epoch-aware stake table state for the next block. …\nmax capacity of stake table\nHelper function for test\nUpdate the pending stake table with <code>num_reg</code> number of new …\nattempt to advance epoch, should be invoked at the …\nReturns the stake table state for current voting\nError when communicating with the smart contract: {0}\nEpoch has already started on block {0}, please upgrade the …\nGas price too high: current {0} gwei, max allowed: {1} gwei\nInternal error: {0}\nInvalid light client state or signatures: {0}\nInternal error when generating the SNARK proof: {0}\nError when communicating with the state relay server: {0}\nError when communicating with the sequencer. Url: {0}, …\nConfiguration/Parameters used for hotshot state prover\nThis function will fetch the cross epoch state update …\nEpoch length in number of Hotshot blocks.\nThe configuration of the prover service\nThe current epoch number of the stake table\nThe epoch start block.\nGet the latest LightClientState and signature bundle from …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRPC client to the L1 (or L2) provider\nAddress of LightClient proxy contract\noptional gas price cap <strong>in wei</strong> to prevent prover sending …\nMaximum number of retires for one-shot prover\nIf daemon and provided, the service will run a basic HTTP …\nRead the following info from the LightClient contract …\nUrl of the state relay server (a CDN that sequencers push …\nInterval between retries if a state update fails\nRun light client state prover once\nRun prover in daemon mode\nURL of a node that is currently providing the HotShot …\nTransaction signing key for Ethereum or any other layer 2\nThe current stake table state\nThe stake table\nStake table capacity for the prover circuit.\nsubmit the latest finalized state along with a proof to …\nSync the light client state from the relay server and …\n<code>ToString::to_string</code>, but without panic on OOM.\nInterval between light client state update\nProof\nProving key\nPublic input to the light client state prover service\nUniversal SRS\nVerifying key\n\\beta times the above generator of G2.\nThe size of the evaluation domain. Should be a power of …\nGiven a proving key and\nTODO: remove h and beta_h The generator of G2.\nA flag indicating whether the key is a merged key.\nThe constants K0, …, K_num_wire_types that ensure wire …\nThe number of public inputs.\nKZG PCS opening key.\n(Aggregated) proof of evaluations at challenge point <code>zeta</code>.\nThe partial proof for Plookup argument\nPlookup verifying key, None if not support lookup.\nPolynomial evaluations.\nGroup elements of the form <code>{ \\beta^i G }</code>, where <code>i</code> ranges …\npowers of \\beta time the generator h of G2\nGiven a SRS, returns the proving key and verifying key for …\nThe polynomial commitment for the wire permutation …\nThe selector polynomial commitments. The commitments are …\n(Aggregated) proof of evaluation at challenge point …\nThe permutation polynomial commitments. The commitments …\nSplit quotient polynomial commitments.\nThe verifying key. It is used by prover to initialize …\nWire witness polynomials commitments.")